View(stats_summary)
stats_summary <- imap_dfr(data_frames_list, function(df, name) {
tibble(
Dataset = name,
Skewness_X = skewness(df$x, na.rm = TRUE),
Skewness_Y = skewness(df$y, na.rm = TRUE),
)
})
# Print the summary statistics
print(stats_summary)
setwd("~/Documents/GitHub/Prob-and-Stats-for-Biomed/Exams/Exam I")
knitr::opts_chunk$set(echo = TRUE)
anscombe <- read.table("anscombe.txt", header = TRUE, sep = "\t")
print(anscombe)
View(anscombe)
anscombe <- read.table("anscombe.txt", header = TRUE, sep = "")
View(anscombe)
gplot(anscombe_data, aes(x = x1, y = y1)) +
geom_point() +
theme_minimal() +
ggtitle("Scatterplot of x1 vs y1") +
xlab("x1") +
ylab("y1")
### Part A:
library(ggplot2)
gplot(anscombe_data, aes(x = x1, y = y1)) +
geom_point() +
theme_minimal() +
ggtitle("Scatterplot of x1 vs y1") +
xlab("x1") +
ylab("y1")
ggplot(anscombe_data, aes(x = x1, y = y1)) +
geom_point() +
theme_minimal() +
ggtitle("Scatterplot of x1 vs y1") +
xlab("x1") +
ylab("y1")
# read txt file
anscombe_data <- read.table("anscombe.txt", header = TRUE, sep = "")
rm(ancombe)
rm(anscombe)
# Names of the x and y columns
x_names <- c("x1", "x2", "x3", "x4")
y_names <- c("y1", "y2", "y3", "y4")
# Loop through each pair of x and y columns
for (i in 1:4) {
# Dynamic plot title and axis labels
plot_title <- sprintf("Scatterplot of %s vs %s", x_names[i], y_names[i])
x_label <- x_names[i]
y_label <- y_names[i]
# Create scatterplot for current pair
p <- ggplot(anscombe_data, aes_string(x = x_names[i], y = y_names[i])) +
geom_point() +
theme_minimal() +
ggtitle(plot_title) +
xlab(x_label) +
ylab(y_label)
# Print the plot
print(p)
}
# Loop through each pair of x and y columns
for (i in 1:4) {
# Dynamic plot title and axis labels
plot_title <- sprintf("Scatterplot of %s vs %s", x_names[i], y_names[i])
x_label <- x_names[i]
y_label <- y_names[i]
# Create scatterplot for current pair
p <- ggplot(anscombe_data, aes(x = .data[[x_names[i]]], y = .data[[y_names[i]]])) +
geom_point() +
theme_minimal() +
ggtitle(plot_title) +
xlab(x_label) +
ylab(y_label)
# Print the plot
print(p)
}
# Loop through each pair of x and y columns
for (i in 1:4) {
# Dynamic plot title and axis labels
plot_title <- sprintf("Scatterplot of %s vs %s", x_names[i], y_names[i])
x_label <- x_names[i]
y_label <- y_names[i]
# Create scatterplot for current pair
p <- ggplot(anscombe_data, aes(x = .data[[x_names[i]]], y = .data[[y_names[i]]])) +
geom_point() +
theme_minimal() +
ggtitle(plot_title) +
xlab(x_label) +
ylab(y_label)
# Print the plot
print(p)
}
ggplot(combined_data, aes(x = x, y = y)) +
geom_point() +
facet_wrap(~ dataset, scales = "free") +
theme_minimal() +
labs(title = "Datasets Scatterplots", x = "X", y = "Y")
stats_summary <- imap_dfr(data_frames_list, function(df, name) {
tibble(
Dataset = name,
Skewness_X = skewness(df$x, na.rm = TRUE),
Skewness_Y = skewness(df$y, na.rm = TRUE),
)
})
### Part D:
library(e1071)
stats_summary <- imap_dfr(data_frames_list, function(df, name) {
tibble(
Dataset = name,
Skewness_X = skewness(df$x, na.rm = TRUE),
Skewness_Y = skewness(df$y, na.rm = TRUE),
)
})
library(readr)
library(dplyr)
library(purrr)
# List all CSV files in the folder
csv_files <- list.files(path = "datasaurus12", pattern = "\\.csv$", full.names = TRUE)
# Create a named list where each name is the file name without the extension
names_list <- tools::file_path_sans_ext(basename(csv_files))
# Read each CSV file into its own data frame within a named list
data_frames_list <- setNames(lapply(csv_files, function(file) read_csv(file, show_col_types = FALSE)), names_list)
### Part A:
# Function to calculate summary statistics for each data frame
calculate_summary <- function(df) {
summary <- df %>%
summarize(
x_mean = mean(x, na.rm = TRUE),
y_mean = mean(y, na.rm = TRUE),
x_sd = sd(x, na.rm = TRUE),
y_sd = sd(y, na.rm = TRUE),
pearson_correlation = cor(x, y, use = "complete.obs")
)
return(summary)
}
# Apply the function to each data frame in the list and combine the results
summary_table <- map_df(data_frames_list, calculate_summary, .id = "Dataset")
# Print the summary table
print(summary_table)
### Part B:
# Combine data into single dataset with id as dataset name
combined_data <- bind_rows(data_frames_list, .id = "dataset")
# Plot each dataset in faceted plot
ggplot(combined_data, aes(x = x, y = y)) +
geom_point() +
facet_wrap(~ dataset, scales = "free") +
theme_minimal() +
labs(title = "Datasets Scatterplots", x = "X", y = "Y")
library(ggplot2)
# read txt file
anscombe_data <- read.table("anscombe.txt", header = TRUE, sep = "")
# Names of the x and y columns
x_names <- c("x1", "x2", "x3", "x4")
y_names <- c("y1", "y2", "y3", "y4")
# Loop through each pair of x and y columns
for (i in 1:4) {
# Dynamic plot title and axis labels
plot_title <- sprintf("Scatterplot of %s vs %s", x_names[i], y_names[i])
x_label <- x_names[i]
y_label <- y_names[i]
# Create scatterplot for current pair
p <- ggplot(anscombe_data, aes(x = .data[[x_names[i]]], y = .data[[y_names[i]]])) +
geom_point() +
theme_minimal() +
ggtitle(plot_title) +
xlab(x_label) +
ylab(y_label)
# Print the plot
print(p)
}
for (i in 1:4) {
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Print model summary
cat("Summary for", x_names[i], "vs", y_names[i], ":\n")
print(summary(lm_model))
# Extract coefficients
intercept <- coef(lm_model)[1]
slope <- coef(lm_model)[2]
# Print linear function
cat("Linear function for", x_names[i], "vs", y_names[i], ":\n")
cat(paste("y =", round(intercept, 3), "+", round(slope, 3), "*", x_names[i], "\n\n"))
}
### Part B:
# Loop through each pair of x and y columns
for (i in 1:4) {
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Print model summary
#cat("Summary for", x_names[i], "vs", y_names[i], ":\n")
#print(summary(lm_model))
# Extract coefficients
intercept <- coef(lm_model)[1]
slope <- coef(lm_model)[2]
# Print linear function
cat("Linear function for", x_names[i], "vs", y_names[i], ":\n")
cat(paste("y =", round(intercept, 3), "+", round(slope, 3), "*", x_names[i], "\n\n"))
}
for (i in 1:4) {
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Print model summary
#cat("Summary for", x_names[i], "vs", y_names[i], ":\n")
#print(summary(lm_model))
# Extract coefficients
intercept <- coef(lm_model)[1]
slope <- coef(lm_model)[2]
# Print linear function
cat("Linear function for", x_names[i], "vs", y_names[i], ":\n")
cat(paste("y =", round(slope, 3), "*", x_names[i], "+", round(intercept, 3)"\n\n"))
for (i in 1:4) {
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Print model summary
#cat("Summary for", x_names[i], "vs", y_names[i], ":\n")
#print(summary(lm_model))
# Extract coefficients
intercept <- coef(lm_model)[1]
slope <- coef(lm_model)[2]
# Print linear function
cat("Linear function for", x_names[i], "vs", y_names[i], ":\n")
cat(paste("y =", round(slope, 3), "*", x_names[i], "+", round(intercept, 3),"\n\n"))
}
par(mfrow = c(2, 2))  # 2x2 layout for 4 plots
# Loop through each pair of x and y columns
for (i in 1:4) {
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Generate residuals
residuals <- residuals(lm_model)
# Generate fitted values
fitted_values <- fitted(lm_model)
# Create residual plot
plot(fitted_values, residuals, main = paste("Residual Plot for", x_names[i], "vs", y_names[i]),
xlab = "Fitted Values", ylab = "Residuals", pch = 19)
# Add a horizontal line at y = 0 for reference
abline(h = 0, col = "red")
}
par(mfrow = c(2, 2))  # 2x2 layout for 4 plots
# Loop through each pair of x and y columns
for (i in 1:4) {
# Calculate residuals
residuals <- anscombe_data[[y_names[i]]] - mean(anscombe_data[[y_names[i]]])
# Create residual plot
plot(anscombe_data[[x_names[i]]], residuals, main = paste("Residual Plot for", x_names[i], "vs", y_names[i]),
xlab = "X Values", ylab = "Residuals", pch = 19)
# Add a horizontal line at y = 0 for reference
abline(h = 0, col = "red")
}
par(mfrow = c(2, 2))  # 2x2 layout for 4 plots
# Loop through each pair of x and y columns
for (i in 1:4) {
# Create plot
plot(anscombe_data[[x_names[i]]], anscombe_data[[y_names[i]]],
main = paste("Scatterplot of", x_names[i], "vs", y_names[i]),
xlab = "X Values", ylab = "Y Values", pch = 19)
}
# Loop through each pair of x and y columns
for (i in 1:4) {
# Create plot
plot(anscombe_data[[x_names[i]]], anscombe_data[[y_names[i]]],
main = paste("Scatterplot of", x_names[i], "vs", y_names[i]),
xlab = "X Values", ylab = "Y Values", pch = 19)
}
for (i in 1:4) {
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Print model summary
#cat("Summary for", x_names[i], "vs", y_names[i], ":\n")
#print(summary(lm_model))
# Extract coefficients
intercept <- coef(lm_model)[1]
slope <- coef(lm_model)[2]
# Print linear function
cat("Linear function for", x_names[i], "vs", y_names[i], ":\n")
cat(paste("y =", round(slope, 3), "*", x_names[i], "+", round(intercept, 3),"\n\n"))
}
# Names of the x and y columns
x_names <- c("x1", "x2", "x3", "x4")
y_names <- c("y1", "y2", "y3", "y4")
par(mfrow = c(2, 2))  # 2x2 layout for 4 plots
# Loop through each pair of x and y columns
for (i in 1:4) {
# Create plot
plot(anscombe_data[[x_names[i]]], anscombe_data[[y_names[i]]],
main = paste("Scatterplot of", x_names[i], "vs", y_names[i]),
xlab = "X Values", ylab = "Y Values", pch = 19)
}
### Part B:
# Loop through each pair of x and y columns
for (i in 1:4) {
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Extract coefficients
intercept <- coef(lm_model)[1]
slope <- coef(lm_model)[2]
# Print linear function
cat("Linear function for", x_names[i], "vs", y_names[i], ":\n")
cat(paste("y =", round(slope, 3), "*", x_names[i], "+", round(intercept, 3),"\n\n"))
}
### Part C:
# Set up the plotting layout
par(mfrow = c(2, 2))  # 2x2 layout for 4 plots
# Loop through each pair of x and y columns
for (i in 1:4) {
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Generate residuals
residuals <- residuals(lm_model)
# Generate fitted values
fitted_values <- fitted(lm_model)
# Create residual plot
plot(fitted_values, residuals, main = paste("Residual Plot for", x_names[i], "vs", y_names[i]),
xlab = "Fitted Values", ylab = "Residuals", pch = 19)
# Add a horizontal line at y = 0 for reference
abline(h = 0, col = "red")
}
# Set up the plotting layout
par(mfrow = c(2, 2))  # 2x2 layout for 4 plots
# Loop through each pair of x and y columns
for (i in 1:4) {
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Generate residuals
residuals <- residuals(lm_model)
# Generate fitted values
fitted_values <- fitted(lm_model)
# Create residual plot
plot(fitted_values, residuals, main = paste("Residual Plot for", x_names[i], "vs", y_names[i]),
xlab = "Fitted Values", ylab = "Residuals", pch = 19)
# Add a horizontal line at y = 0 for reference
abline(h = 0, col = "red")
# Plot the slope of the regression line
abline(lm_model, col = "blue")
}
par(mfrow = c(2, 2))  # 2x2 layout for 4 plots
# Loop through each pair of x and y columns
for (i in 1:4) {
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Generate residuals
residuals <- residuals(lm_model)
# Generate fitted values
fitted_values <- fitted(lm_model)
# Create residual plot
plot(fitted_values, residuals, main = paste("Residual Plot for", x_names[i], "vs", y_names[i]),
xlab = "Fitted Values", ylab = "Residuals", pch = 19)
# Add a horizontal line at y = 0 for reference
#abline(h = 0, col = "red")
# Plot the slope of the regression line
abline(lm_model, col = "blue")
}
par(mfrow = c(2, 2))  # 2x2 layout for 4 plots
# Loop through each pair of x and y columns
for (i in 1:4) {
# Create plot
plot(anscombe_data[[x_names[i]]], anscombe_data[[y_names[i]]],
main = paste("Scatterplot of", x_names[i], "vs", y_names[i]),
xlab = "X Values", ylab = "Y Values", pch = 19)
# Create linear model
lm_model <- lm(anscombe_data[[y_names[i]]] ~ anscombe_data[[x_names[i]]], data = anscombe_data)
# Add the regression line
abline(lm_model, col = "blue")
}
# Calculate probabilities
p_phrase_given_spam <- 210 / 1000  # Probability of phrase given spam
p_spam <- 0.5  # Prior probability of spam
p_phrase_given_non_spam <- 23 / 1000  # Probability of phrase given non-spam
# Calculate denominator for Bayes' theorem
p_phrase <- (p_phrase_given_spam * p_spam) + (p_phrase_given_non_spam * (1 - p_spam))
# Apply Bayes' theorem
p_spam_given_phrase <- (p_phrase_given_spam * p_spam) / p_phrase
# Print the result
print(p_spam_given_phrase)
# Print the result
cat("Probability: ",p_spam_given_phrase)
cleaveland <- read.csv("heart_cleaveland_upload.csv")
library(readr)
heart_cleveland_upload <- read_csv("heart_cleveland_upload.csv")
View(heart_cleveland_upload)
View(heart_cleveland_upload)
cleaveland <- read.csv("heart_cleaveland_upload.csv")
setwd("~/Documents/GitHub/Prob-and-Stats-for-Biomed/Exams/Exam I")
cleaveland <- read.csv("heart_cleaveland_upload.csv")
cleaveland <- read.csv("heart_cleveland_upload.csv")
rm(heart_cleveland_upload)
# Part A:
# Calculate the number of patients with less than 50 percent diameter narrowing
patients_less_than_50 <- sum(cleaveland$condition == 0)
# Total number of patients
total_patients <- nrow(cleaveland)
# Calculate the probability of a patient having less than 50 percent diameter narrowing
probability_less_than_50 <- patients_less_than_50 / total_patients
# Print the results
cat("Number of patients with less than 50% diameter narrowing:", patients_less_than_50, "\n")
cat("Total number of patients:", total_patients, "\n")
cat("Probability of a patient having less than 50% diameter narrowing:", probability_less_than_50, "\n")
# Part A:
# Calculate the number of patients with less than 50 percent diameter narrowing
patients_less_than_50 <- sum(cleaveland$condition == 0)
# Total number of patients
total_patients <- nrow(cleaveland)
# Calculate the probability of a patient having less than 50 percent diameter narrowing
probability_less_than_50 <- patients_less_than_50 / total_patients
# Calculate the probability of at least 3 out of 25 patients having less than 50% diameter narrowing
probability_at_least_3 <- 1 - pbinom(2, size = 25, prob = probability_less_than_50)
cat("Probability: ", probability_at_least_3, "\n")
# Part A:
# Calculate the number of patients with less than 50 percent diameter narrowing
patients_less_than_50 <- sum(cleaveland$condition == 0)
# Total number of patients
total_patients <- nrow(cleaveland)
# Calculate the probability of a patient having less than 50 percent diameter narrowing
probability_less_than_50 <- patients_less_than_50 / total_patients
# Calculate the probability of at least 3 out of 25 patients having less than 50% diameter narrowing
probability_at_least_3 <- 1 - pbinom(2, size = 25, prob = probability_less_than_50)
cat("Probability: ", probability_at_least_3, "\n")
# Part A:
# Calculate the number of patients with less than 50 percent diameter narrowing
patients_less_than_50 <- sum(cleaveland$condition == 0)
# Total number of patients
total_patients <- nrow(cleaveland)
# Calculate the probability of a patient having less than 50 percent diameter narrowing
probability_less_than_50 <- patients_less_than_50 / total_patients
# Calculate the probability of at least 3 out of 25 patients having less than 50% diameter narrowing
probability_at_least_3 <- 1 - pbinom(2, size = 25, prob = probability_less_than_50)
cat("Probability: ", probability_at_least_3, "\n")
# Print the result
cat("Probability: ", average_patients_before_success, "\n")
# Calculate the probability of a patient having cholesterol levels >= 300
patients_with_cholesterol_above_300 <- sum(df$chol >= 300)
patients_with_cholesterol_above_300 <- sum(cleaveland$chol >= 300)
total_patients <- nrow(cleaveland)
probability_cholesterol_above_300 <- patients_with_cholesterol_above_300 / total_patients
# The mean (or expected value) for the geometric distribution
# This is the average number of patients examined before finding one with cholesterol >= 300
average_patients_before_success <- 1 / probability_cholesterol_above_300
# Print the result
cat("Probability: ", average_patients_before_success, "\n")
# Print the result
cat("Average number of patients: ", average_patients_before_success, "\n")
# Print the result
cat("Average number of patients before the first patient with cholesterol levels above than 300: ", average_patients_before_success, "\n")
# Calculate the mean of 'thalach'
mean_thalach <- mean(cleaveland$thalach)
# Calculate the variance of 'thalach'
variance_thalach <- var(cleaveland$thalach)
cleveland <- read.csv("heart_cleveland_upload.csv")
rm(cleaveland)
leveland <- read.csv("heart_cleveland_upload.csv")
### Part A:
# Calculate the number of patients with less than 50 percent diameter narrowing
patients_less_than_50 <- sum(cleveland$condition == 0)
# Total number of patients
total_patients <- nrow(cleveland)
# Calculate the probability of a patient having less than 50 percent diameter narrowing
probability_less_than_50 <- patients_less_than_50 / total_patients
# Calculate the probability of at least 3 out of 25 patients having less than 50% diameter narrowing
probability_at_least_3 <- 1 - pbinom(2, size = 25, prob = probability_less_than_50)
cat("Probability: ", probability_at_least_3, "\n")
### Part B:
# Calculate the probability of a patient having cholesterol levels >= 300
patients_with_cholesterol_above_300 <- sum(cleveland$chol >= 300)
probability_cholesterol_above_300 <- patients_with_cholesterol_above_300 / total_patients
# The mean (or expected value) for the geometric distribution
# This is the average number of patients examined before finding one with cholesterol >= 300
average_patients_before_success <- 1 / probability_cholesterol_above_300
# Print the result
cat("Average number of patients before the first patient with cholesterol levels above than 300: ", average_patients_before_success, "\n")
```
thalach <- cleveland$thalach
# Number of bootstrap samples
n_bootstraps <- 10000
# Initialize vectors to store the results
bootstrap_means <- numeric(n_bootstraps)
bootstrap_medians <- numeric(n_bootstraps)
bootstrap_variances <- numeric(n_bootstraps)
# Perform the bootstrap resampling
set.seed(1) # for reproducibility
for (i in 1:n_bootstraps) {
bootstrap_sample <- sample(thalach, replace = TRUE, size = length(thalach))
bootstrap_means[i] <- mean(bootstrap_sample)
bootstrap_medians[i] <- median(bootstrap_sample)
bootstrap_variances[i] <- var(bootstrap_sample)
}
# Calculate the mean of the bootstrap means
mean_of_means <- mean(bootstrap_means)
# Calculate the standard deviation of the bootstrap means
sd_of_means <- sd(bootstrap_means)
# Calculate the standard error of the mean
se_of_means <- sd_of_means / sqrt(length(bootstrap_means))
# Calculate the 95% confidence interval of the mean
ci_95 <- quantile(bootstrap_means, c(0.025, 0.975))
# Print the results
print(paste("Mean of bootstrap means:", mean_of_means))
print(paste("Standard deviation of bootstrap means:", sd_of_means))
print(paste("Standard error of bootstrap means:", se_of_means))
print(paste("95% CI of bootstrap means:", ci_95[1], "-", ci_95[2]))
# Print the results
cat("Mean of bootstrap means:", mean_of_means))
# Print the results
cat("Mean of bootstrap means:", mean_of_means, "\n")
cat("Standard deviation of bootstrap means:", sd_of_means, "\n")
cat("Standard error of bootstrap means:", se_of_means, "\n")
cat("95% CI of bootstrap means:", ci_95[1], "-", ci_95[2], "\n")
# Create a density plot for the bootstrap means
ggplot(data.frame(BootstrapMeans = bootstrap_means), aes(x = BootstrapMeans)) +
geom_density(fill="blue", alpha=0.5) +
labs(title="Density Plot of Bootstrap Means",
x="Mean of Bootstrap Samples",
y="Density") +
theme_minimal()
