library("GGally")
# Extract the first 4 principal components
pca_subset <- pca_result$x[, 1:4]
# Assuming pca_subset is a matrix
pca_subset <- as.data.frame(pca_subset)
# Add diagnosis column to pca_subset
pca_subset$Diagnosis <- factor(pca_groups$Diagnosis, levels = c(0, 1), labels = c("normal", "tumor"))
# PCA1 vs PCA2
fviz_pca_ind(pca_result,
geom.ind = "point",            # Show points only
col.ind = factor(pca_subset$Diagnosis, levels = unique(pca_subset$Diagnosis)),  # Color by groups
palette = c("steelblue2", "firebrick3"),
addEllipses = TRUE,           # Concentration ellipses
legend.title = "Groups",
title = "PC1 vs PC2",
col.lab = c("normal" = "steelblue2", "tumor" = "firebrick3"))
# Perform logistic regression using the principal components
lg_model <- glm(Diagnosis ~ ., data = pc_scores, family = "binomial")
lg_reduced <- glm(Diagnosis ~ PC1, data = pc_scores, family = "binomial")
# compare reduced with full model
anova(lg_reduced, lg_model, test = "LRT")
# the p-value is > 0.05.
# Therefore, we fail to reject the null hypothesis, suggesting that using 1 PCA component is a better model than using all PCA components.
# Check the summary of the model
summary(lg_reduced)
# OR for PC1
exp(coef(lg_reduced)["PC1"])
# The p-value is <0.05 so we conclude that PC1 gene expression is significantly associated with the presence of tumor.
# the odds of developing a tumor from PC1 gene expression is 2.95 times that of non-expression.
par(mfrow = c(2, 2))
plot(lg_reduced)
# Flatten the dataframe into a single vector
data_vector <- as.vector(unlist(scaled))
# Calculate quartiles
Q1 <- quantile(data_vector, 0.25)
Q3 <- quantile(data_vector, 0.75)
# Calculate IQR
IQR <- Q3 - Q1
# Define lower and upper bounds for outliers
lower_bound <- Q1 - 4 * IQR
upper_bound <- Q3 + 4 * IQR
# Identify outliers
outliers <- data_vector[data_vector < lower_bound | data_vector > upper_bound]
# Find rows where any value is higher than the upper bound
rows_to_remove <- which(apply(scaled, 1, function(row) any(row > upper_bound)))
# Remove identified rows from the dataframe
scaled <- scaled[-rows_to_remove, ]
# Set up the layout for the plots
par(mfrow = c(1, 2))
# Flatten the dataframe into a single vector
dv1 <- as.vector(unlist(filtered))
dv2 <- as.vector(unlist(scaled))
# Plot histogram of unscaled data
hist(dv1,main = "Unscaled Expression", xlab = "Expression", breaks = 100)
hist(dv2, main = "Scaled Expression", xlab = "Expression", breaks = 100)
# Flatten the dataframe into a single vector
data_vector <- as.vector(unlist(scaled))
# Calculate quartiles
Q1 <- quantile(data_vector, 0.25)
Q3 <- quantile(data_vector, 0.75)
# Calculate IQR
IQR <- Q3 - Q1
# Define lower and upper bounds for outliers
lower_bound <- Q1 - 4 * IQR
upper_bound <- Q3 + 4 * IQR
# Identify outliers
outliers <- data_vector[data_vector < lower_bound | data_vector > upper_bound]
# Find rows where any value is higher than the upper bound
rows_to_remove <- which(apply(scaled, 1, function(row) any(row > upper_bound)))
# Remove identified rows from the dataframe
scaled <- scaled[-rows_to_remove, ]
# Set up the layout for the plots
par(mfrow = c(1, 2))
# Flatten the dataframe into a single vector
dv1 <- as.vector(unlist(filtered))
dv2 <- as.vector(unlist(scaled))
# Plot histogram of unscaled data
hist(dv1,main = "Raw Expression", xlab = "Expression", breaks = 100)
hist(dv2, main = "Transformed and Scaled Expression", xlab = "Expression", breaks = 100)
# Flatten the dataframe into a single vector
data_vector <- as.vector(unlist(scaled))
# Calculate quartiles
Q1 <- quantile(data_vector, 0.25)
Q3 <- quantile(data_vector, 0.75)
# Calculate IQR
IQR <- Q3 - Q1
# Define lower and upper bounds for outliers
lower_bound <- Q1 - 4 * IQR
upper_bound <- Q3 + 4 * IQR
# Identify outliers
outliers <- data_vector[data_vector < lower_bound | data_vector > upper_bound]
# Find rows where any value is higher than the upper bound
rows_to_remove <- which(apply(scaled, 1, function(row) any(row > upper_bound)))
# Remove identified rows from the dataframe
scaled <- scaled[-rows_to_remove, ]
# Set up the layout for the plots
par(mfrow = c(1, 2))
# Flatten the dataframe into a single vector
dv1 <- as.vector(unlist(filtered))
dv2 <- as.vector(unlist(scaled))
# Plot histogram of unscaled data
hist(dv1, main = "Raw Expression", xlab = "Expression", breaks = 100)
hist(dv2, main = "Transformed and Scaled", xlab = "Expression", breaks = 100)
View(scaled)
# Get the names of all objects in the environment
all_objects <- ls()
# Remove all objects except "df"
objects_to_remove <- setdiff(all_objects, c("part1", "part2", "part3", "part4", "part5", "part6", "genes", "bigdata"))
rm(list = objects_to_remove)
# genes of interest
genes_interest <- genes$symbol
# filter data
data <- bigdata[bigdata$X %in% genes_interest, ]
# add diagnosis
diagnosis_row <- bigdata[1, ]
data <- rbind(diagnosis_row, data)
# Remove duplicate rows
data <- data[!duplicated(data[, 1]), ]
# Transpose data
df <- as.data.frame(t(data))
# Set column names
colnames(df) <- as.character(unlist(df[1, ]))
df <- df[-1, ]
# Drop ID Column
rownames(df) <- NULL
# convert to numeric
df[, -1] <- lapply(df[, -1], as.numeric)
# Impute NA with 0 since there are very few
df[is.na(df)] <- 0
# Set diatnosis column
colnames(df)[1] <- "Diagnosis"
# convert diagnosis to numeric
df$Diagnosis <- ifelse(df$Diagnosis == "normal", 0, 1)
#  Remove columns that have no entries
column_sums <- colSums(df)
nonzero_columns <- which(column_sums != 0)
df <- df[, nonzero_columns, drop = FALSE]
# Convert diagnosis to a factor for easier subsetting
df$Diagnosis <- factor(df$Diagnosis)
combinedData <- subset(df)
# Split data into two groups based on Diagnosis
normalData <- subset(df, Diagnosis == 0)
tumorData <- subset(df, Diagnosis == 1)
set_row_names <- function(df) {
# Initialize counters for normal and tumor rows
normal_count <- 0
tumor_count <- 0
# Iterate through the diagnosis column to count normal and tumor rows
for (i in 1:nrow(df)) {
if (df$Diagnosis[i] == 0) {
normal_count <- normal_count + 1
row.names(df)[i] <- paste("N", normal_count, sep="_")
} else if (df$Diagnosis[i] == 1) {
tumor_count <- tumor_count + 1
row.names(df)[i] <- paste("T", tumor_count, sep="_")
}
}
return(df)
}
# Call the function with your dataframe
combinedData <- set_row_names(combinedData)
normalData <- set_row_names(normalData)
tumorData <- set_row_names(tumorData)
# remove original diagnosis column
combinedData <- combinedData[, -which(names(combinedData) == "Diagnosis")]
normalData <- normalData[, -which(names(normalData) == "Diagnosis")]
tumorData <- tumorData[, -which(names(tumorData) == "Diagnosis")]
# Initialize vectors to store results
log2FC <- numeric(ncol(combinedData))
pValues <- numeric(ncol(combinedData))
for (i in 1:(ncol(combinedData))) {
geneExpressionNormal <- normalData[,i]
geneExpressionTumor <- tumorData[,i]
# Calculate log2 Fold Change (tumor vs normal)
log2FC[i] <- log2(mean(geneExpressionTumor) / mean(geneExpressionNormal))
# Calculate p-value using Welch's t-test
pValues[i] <- t.test(geneExpressionTumor, geneExpressionNormal)$p.value
}
# Create a data frame to store results
results <- data.frame(
Gene = colnames(df)[-1],  # Exclude the Diagnosis column
Log2FoldChange = log2FC,
PValue = pValues
)
library(ggplot2)
# Convert p-values to -log10(p-value) for plotting
results$NegLogPValue <- -log10(results$PValue)
# Define up-regulated and down regulated genes
results$ChangeCategory <- with(results,
ifelse(PValue < 0.05 & Log2FoldChange > 1.5, "Upregulated",
ifelse(PValue < 0.05 & Log2FoldChange < -1.5, "Downregulated", "Nonsignificant")))
# Define genes of interest
results$IsInterest <- ifelse(results$Gene %in% genes_interest, "Yes", "No")
# Create the volcano plot
volcanoPlot <- ggplot(results, aes(x=Log2FoldChange, y=NegLogPValue, color=ChangeCategory)) +
geom_point(alpha=0.5) +
scale_color_manual(values=c("Upregulated"="red4", "Downregulated"="royalblue4", "Nonsignificant"="grey")) +
labs(x="Log2 Fold Change", y="-Log10 P-value", title="Volcano Plot of Gene Expression") +
theme_minimal() +
geom_hline(yintercept=-log10(0.05), linetype="dashed", color = "black") +  # Significance threshold line
theme(legend.title=element_blank(), legend.position="right")  # Customize legend
volcanoPlot <- volcanoPlot +
geom_vline(xintercept = -1.5, linetype = "dashed", color = "black") +
geom_vline(xintercept = 1.5, linetype = "dashed", color = "black")
# Add labels to genes of interest
volcanoPlot <- volcanoPlot + geom_text(data=subset(results, IsInterest == "Yes"), aes(label=Gene), vjust=-0.5, hjust=0.5, check_overlap = TRUE, size=3, color="black")
# Print the plot
print(volcanoPlot)
# filter for significant genes. p-value <0.05 and absolute value of fold change >1.5
result_mask <- subset(results, PValue < 0.05 & abs(Log2FoldChange) > 1.5)
# filter data
filtered <- df[, c("Diagnosis", intersect(colnames(df), result_mask$Gene))]
filtered <- as.data.frame(lapply(filtered, as.numeric))
filtered$Diagnosis <- ifelse(filtered$Diagnosis == 1, 0, ifelse(filtered$Diagnosis == 2, 1, filtered$Diagnosis))
filtered <- set_row_names(filtered)
# filter normal
filteredNormal <- filtered[filtered$Diagnosis == 0, ]
filteredNormal <- filteredNormal[, -1]
filteredNormal <- as.data.frame(lapply(filteredNormal, as.numeric))
# filter tumor
filteredTumor <- filtered[filtered$Diagnosis == 1, ]
filteredTumor <- filteredTumor[,-1]
filteredTumor <- as.data.frame(lapply(filteredTumor, as.numeric))
# Scale data
scaled <- log2((filtered[,-1])+1)
scaled <- scale(scaled)
scaledNormal <- log2(filteredNormal+1)
scaledNormal <- scale(scaledNormal)
scaledNormal <- replace(scaledNormal, is.na(scaledNormal), 0)
scaledTumor <- log2(filteredTumor+1)
scaledTumor <- scale(scaledTumor)
# Function to add labels to genes with highest expression
add_labels_highest_expression <- function(data, num_labels) {
highest_genes <- colnames(data)[order(apply(data, 2, max), decreasing = TRUE)[1:num_labels]]
for (gene in highest_genes) {
expression_value <- max(data[, gene])
text(which(colnames(data) == gene), expression_value, gene, pos = 1, col = "firebrick3", cex = 1)
}
}
# Plot boxplot for normalData expression
boxplot(scaledNormal,
outline = TRUE,
main = "Normal Gene Expression",
ylab = "Expression",
xlab = "Genes")
# Plot boxplot for tumorData expression
boxplot(scaledTumor,
outline = TRUE,
main = "Tumor Gene Expression",
ylab = "Expression",
xlab = "Genes")
#add_labels_highest_expression(scaledTumor, 1)
# Flatten the dataframe into a single vector
data_vector <- as.vector(unlist(scaled))
# Calculate quartiles
Q1 <- quantile(data_vector, 0.25)
Q3 <- quantile(data_vector, 0.75)
# Calculate IQR
IQR <- Q3 - Q1
# Define lower and upper bounds for outliers
lower_bound <- Q1 - 4 * IQR
upper_bound <- Q3 + 4 * IQR
# Identify outliers
outliers <- data_vector[data_vector < lower_bound | data_vector > upper_bound]
# Find rows where any value is higher than the upper bound
rows_to_remove <- which(apply(scaled, 1, function(row) any(row > upper_bound)))
# Remove identified rows from the dataframe
scaled <- scaled[-rows_to_remove, ]
# Set up the layout for the plots
par(mfrow = c(1, 2))
# Flatten the dataframe into a single vector
dv1 <- as.vector(unlist(filtered))
dv2 <- as.vector(unlist(scaled))
# Plot histogram of unscaled data
hist(dv1, main = "Raw Expression", xlab = "Expression", breaks = 100)
hist(dv2, main = "Transformed and Scaled", xlab = "Expression", breaks = 100)
library(tidyverse)
library(magrittr)
library(pheatmap)
library(RColorBrewer)
library(rio)
library(dplyr)
# filter for heatmap
gene_mask <- result_mask$Gene
m_normalData <- normalData[, colnames(normalData) %in% gene_mask]
m_tumorData <- tumorData[, colnames(tumorData) %in% gene_mask]
m_combinedData <- combinedData[, colnames(combinedData) %in% gene_mask]
# transpose
t_normalData <- as.data.frame(t(m_normalData))
t_tumorData <- as.data.frame(t(m_tumorData))
t_combinedData <- as.data.frame(t(m_combinedData))
# scale data for heatmap
normal_log2 <- log2(t_normalData + 1)
tumor_log2 <- log2(t_tumorData + 1)
combined_log2 <- log2(t_combinedData +1)
# Check for rows with constant values and exclude constant rows
remove_constant_rows <- function(data) {
constant_rows <- apply(data, 1, function(x) all(x == x[1]))
filtered_data <- data[!constant_rows, ]
return(filtered_data)
}
normal_log2 <- remove_constant_rows(normal_log2)
tumor_log2 <- remove_constant_rows(tumor_log2)
combined_log2 <- remove_constant_rows(combined_log2)
# Set seed for reproducibility
set.seed(123)
# random patients
tumor_random_patients = sample(colnames(t_tumorData), 50)
combined_random_patients <- c(sample(colnames(t_normalData), 25), sample(colnames(t_tumorData), 25))
# random genes
#random_genes = sample(rownames(t_normalData), 10)
# top genes
top_genes = result_mask %>% arrange(`PValue`) %>% head(20) %$% Gene
# colors
my_colors = rev(brewer.pal(n = 11, name = "RdBu"))
# ovearll heat map
pheatmap(combined_log2[top_genes, combined_random_patients],
scale = "row",
cluster_rows = FALSE,
color = my_colors,
main = "Heatmap of Gene Expression",
xlab = "Random Samples",
ylab = "Genes",
legend_breaks = c(-2, 2),
legend_labels = c("Downregulated", "Upregulated"))
library(factoextra)
# create filtered pca dataframe
pca_df <- data.frame(scaled)
pca_groups <- data.frame(Diagnosis = filtered$Diagnosis)
pca_groups <- as.data.frame(pca_groups[-rows_to_remove, ])
colnames(pca_groups)[1] <- "Diagnosis"
# perform pca
pca_result <- prcomp(pca_df, scale. = FALSE)
# Examine the summary of PCA result to decide on the number of components
#summary(pca_result)
# Select the Number of Principal Components
cumulative_var <- cumsum(pca_result$sdev^2) / sum(pca_result$sdev^2)
# Extract a number of principal components, for example, the first two
num_components <- 2  # Adjust based on your analysis
pc_scores <- data.frame(pca_result$x[, 1:num_components])
# Add the Diagnosis back to the principal components dataframe and convert to factor
pc_scores <- cbind(pca_groups, pc_scores)
pc_scores$Diagnosis <- as.factor(pc_scores$Diagnosis)
pc_scores <- as.data.frame(pc_scores)
# Get eigenvalues
eigenvectors <- pca_result$rotation
library("GGally")
# Extract the first 4 principal components
pca_subset <- pca_result$x[, 1:4]
# Assuming pca_subset is a matrix
pca_subset <- as.data.frame(pca_subset)
# Add diagnosis column to pca_subset
pca_subset$Diagnosis <- factor(pca_groups$Diagnosis, levels = c(0, 1), labels = c("normal", "tumor"))
# PCA1 vs PCA2
fviz_pca_ind(pca_result,
geom.ind = "point",            # Show points only
col.ind = factor(pca_subset$Diagnosis, levels = unique(pca_subset$Diagnosis)),  # Color by groups
palette = c("steelblue2", "firebrick3"),
addEllipses = TRUE,           # Concentration ellipses
legend.title = "Groups",
title = "PC1 vs PC2",
col.lab = c("normal" = "steelblue2", "tumor" = "firebrick3"))
# Perform logistic regression using the principal components
lg_model <- glm(Diagnosis ~ ., data = pc_scores, family = "binomial")
lg_reduced <- glm(Diagnosis ~ PC1, data = pc_scores, family = "binomial")
# compare reduced with full model
anova(lg_reduced, lg_model, test = "LRT")
# the p-value is > 0.05.
# Therefore, we fail to reject the null hypothesis, suggesting that using 1 PCA component is a better model than using all PCA components.
# Check the summary of the model
summary(lg_reduced)
# OR for PC1
exp(coef(lg_reduced)["PC1"])
# The p-value is <0.05 so we conclude that PC1 gene expression is significantly associated with the presence of tumor.
# the odds of developing a tumor from PC1 gene expression is 2.95 times that of non-expression.
par(mfrow = c(2, 2))
plot(lg_reduced)
# Scale data
scaled <- log2((filtered[,-1])+1)
scaled <- scale(scaled)
scaledNormal <- log2(filteredNormal+1)
scaledNormal <- scale(scaledNormal)
scaledNormal <- replace(scaledNormal, is.na(scaledNormal), 0)
scaledTumor <- log2(filteredTumor+1)
scaledTumor <- scale(scaledTumor)
# Function to add labels to genes with highest expression
add_labels_highest_expression <- function(data, num_labels) {
highest_genes <- colnames(data)[order(apply(data, 2, max), decreasing = TRUE)[1:num_labels]]
for (gene in highest_genes) {
expression_value <- max(data[, gene])
text(which(colnames(data) == gene), expression_value, gene, pos = 1, col = "firebrick3", cex = 1)
}
}
# Set up the layout for the plots
par(mfrow = c(1, 2))
# Plot boxplot for normalData expression
boxplot(scaledNormal,
outline = TRUE,
main = "Normal Gene Expression",
ylab = "Expression",
xlab = "Genes")
# Plot boxplot for tumorData expression
boxplot(scaledTumor,
outline = TRUE,
main = "Tumor Gene Expression",
ylab = "Expression",
xlab = "Genes")
#add_labels_highest_expression(scaledTumor, 1)
# Scale data
scaled <- log2((filtered[,-1])+1)
scaled <- scale(scaled)
scaledNormal <- log2(filteredNormal+1)
scaledNormal <- scale(scaledNormal)
scaledNormal <- replace(scaledNormal, is.na(scaledNormal), 0)
scaledTumor <- log2(filteredTumor+1)
scaledTumor <- scale(scaledTumor)
# Function to add labels to genes with highest expression
add_labels_highest_expression <- function(data, num_labels) {
highest_genes <- colnames(data)[order(apply(data, 2, max), decreasing = TRUE)[1:num_labels]]
for (gene in highest_genes) {
expression_value <- max(data[, gene])
text(which(colnames(data) == gene), expression_value, gene, pos = 1, col = "firebrick3", cex = 1)
}
}
# Set up the layout for the plots
par(mfrow = c(1, 2))
# Plot boxplot for normalData expression
boxplot(scaledNormal,
outline = TRUE,
main = "Normal Gene Expression",
ylab = "Expression",
xlab = "Genes")
# Plot boxplot for tumorData expression
boxplot(scaledTumor,
outline = TRUE,
main = "Tumor Gene Expression",
ylab = "Expression",
xlab = "Genes")
#add_labels_highest_expression(scaledTumor, 1)
# Scale data
scaled <- log2((filtered[,-1])+1)
scaled <- scale(scaled)
scaledNormal <- log2(filteredNormal+1)
scaledNormal <- scale(scaledNormal)
scaledNormal <- replace(scaledNormal, is.na(scaledNormal), 0)
scaledTumor <- log2(filteredTumor+1)
scaledTumor <- scale(scaledTumor)
# Function to add labels to genes with highest expression
add_labels_highest_expression <- function(data, num_labels) {
highest_genes <- colnames(data)[order(apply(data, 2, max), decreasing = TRUE)[1:num_labels]]
for (gene in highest_genes) {
expression_value <- max(data[, gene])
text(which(colnames(data) == gene), expression_value, gene, pos = 1, col = "firebrick3", cex = 1)
}
}
# Set up the layout for the plots
par(mfrow = c(1, 2))
# Plot boxplot for normalData expression
boxplot(scaledNormal,
outline = TRUE,
main = "Normal Gene Expression",
ylab = "Expression",
xlab = "Genes")
# Plot boxplot for tumorData expression
boxplot(scaledTumor,
outline = TRUE,
main = "Tumor Gene Expression",
ylab = "Expression",
xlab = "Genes")
#add_labels_highest_expression(scaledTumor, 1)
boxplot(scaled,
outline = TRUE,
main = "Normal Gene Expression",
ylab = "Expression",
xlab = "Genes")
# Scale data
scaled <- log2((filtered[,-1])+1)
scaled <- scale(scaled)
scaledNormal <- log2(filteredNormal+1)
scaledNormal <- scale(scaledNormal)
scaledNormal <- replace(scaledNormal, is.na(scaledNormal), 0)
scaledTumor <- log2(filteredTumor+1)
scaledTumor <- scale(scaledTumor)
# Function to add labels to genes with highest expression
add_labels_highest_expression <- function(data, num_labels) {
highest_genes <- colnames(data)[order(apply(data, 2, max), decreasing = TRUE)[1:num_labels]]
for (gene in highest_genes) {
expression_value <- max(data[, gene])
text(which(colnames(data) == gene), expression_value, gene, pos = 1, col = "firebrick3", cex = 1)
}
}
# Plot boxplot for normalData expression
boxplot(scaled,
outline = TRUE,
main = "Normal Gene Expression",
ylab = "Expression",
xlab = "Genes")
# Set up the layout for the plots
par(mfrow = c(1, 2))
# Plot boxplot for normalData expression
boxplot(scaledNormal,
outline = TRUE,
main = "Gene Expression",
ylab = "Expression",
xlab = "Genes")
# Plot boxplot for tumorData expression
boxplot(scaledTumor,
outline = TRUE,
main = "Tumor Gene Expression",
ylab = "Expression",
xlab = "Genes")
#add_labels_highest_expression(scaledTumor, 1)
