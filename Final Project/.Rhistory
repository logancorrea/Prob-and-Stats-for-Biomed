library(tidyverse)
library(magrittr)
library(pheatmap)
packages.install("pheatmap")
install.packages("pheatmap")
library(tidyverse)
library(magrittr)
library(pheatmap)
library(RColorBrewer)
library(rio)
install.packages("rio")
install.packages("magrittr")
install.packages("magrittr")
install.packages("RColorBrewer")
library(tidyverse)
library(magrittr)
library(pheatmap)
library(RColorBrewer)
library(rio)
#https://igordot.github.io/tutorials/heatmaps-2017-07.nb.html
data <- read.csv("Data2/LUSC_test.csv", sep = "|")
setwd("~/GitHub/Prob-and-Stats-for-Biomed/Final Project")
library(tidyverse)
library(magrittr)
library(pheatmap)
library(RColorBrewer)
library(rio)
#https://igordot.github.io/tutorials/heatmaps-2017-07.nb.html
data <- read.csv("Data2/LUSC_test.csv", sep = "|")
genes <- read.table("Data/frequently-mutated-genes.2024-03-18.tsv", header = TRUE, sep = "\t", fill = TRUE, quote = "")
# Remove duplicate rows
data <- data[!duplicated(data[, 1]), ]
#data <- data[1:6000, ]
# Transpose data
df <- t(data)
# Convert to data frame
df <- as.data.frame(df)
# Set column names
colnames(df) <- as.character(unlist(df[1, ]))
df <- df[-1, ]
# Drop ID Column
rownames(df) <- NULL
# convert to numeric
df[, -1] <- lapply(df[, -1], as.numeric)
# Impute NA with 0 since there are very few
df[is.na(df)] <- 0
# convert diagnosis to numeric
df$Diagnosis <- ifelse(df$Diagnosis == "normal", 0, 1)
# Convert diagnosis to a factor for easier subsetting
df$Diagnosis <- factor(df$Diagnosis)
# Split data into two groups based on Diagnosis
normalData <- subset(df, Diagnosis == 0)[,-1]
tumorData <- subset(df, Diagnosis == 1)[,-1]
# get genes of interest
genes_interest <- genes$symbol
# Initialize vectors to store results
log2FC <- numeric(ncol(df) - 1)  # Subtract 1 to exclude the Diagnosis column
pValues <- numeric(ncol(df) - 1)
for (i in 1:(ncol(df) - 1)) {
geneExpressionNormal <- normalData[,i]
geneExpressionTumor <- tumorData[,i]
# Calculate log2 Fold Change (tumor vs normal)
log2FC[i] <- log2(mean(geneExpressionTumor) / mean(geneExpressionNormal))
# Calculate p-value using Welch's t-test
pValues[i] <- t.test(geneExpressionTumor, geneExpressionNormal)$p.value
}
# Create a data frame to store results
results <- data.frame(
Gene = colnames(df)[-1],  # Exclude the Diagnosis column
Log2FoldChange = log2FC,
PValue = pValues
)
# transpose
t_normalData <- as.data.frame(t(normalData))
t_tumorData <- as.data.frame(t(tumorData))
# scale data
normal_log2 = log2(t_normalData + 1)
tumor_log2 = log2(t_tumorData + 1)
# Check for rows with constant values and exclude constant rows
remove_constant_rows <- function(data) {
constant_rows <- apply(data, 1, function(x) all(x == x[1]))
filtered_data <- data[!constant_rows, ]
return(filtered_data)
}
normal_log2 <- remove_constant_rows(normal_log2)
tumor_log2 <- remove_constant_rows(tumor_log2)
# Arrange by significance
library(dplyr)
# random patients
random_patients = sample(colnames(t_normalData), 10)
# random genes
random_genes = sample(rownames(t_normalData), 10)
# top genes
top_genes = results %>% arrange(`PValue`) %>% head(10) %$% Gene
# colors
my_colors = brewer.pal(n = 11, name = "RdBu")
pheatmap(normal_log2[top_genes, ], scale = "row", color = my_colors)
pheatmap(tumor_log2[top_genes, ], scale = "row", color = my_colors)
pheatmap(tumor_log2[top_genes, random_patients], scale = "row", color = my_colors)
# random patients
random_patients = sample(colnames(t_normalData), 10)
pheatmap(tumor_log2[top_genes, random_patients], scale = "row", color = my_colors)
# random patients
random_patients = sample(colnames(t_tumorData), 10)
pheatmap(tumor_log2[top_genes, random_patients], scale = "row", color = my_colors)
# random patients
random_patients = sample(colnames(t_tumorData), 50)
pheatmap(tumor_log2[top_genes, random_patients], scale = "row", color = my_colors)
pheatmap(normal_log2[top_genes, ], scale = "row", color = my_colors)
pheatmap(tumor_log2[top_genes, random_patients], scale = "row", color = my_colors)
# Set seed for reproducibility
set.seed(123)
# random patients
random_patients = sample(colnames(t_tumorData), 50)
# random genes
random_genes = sample(rownames(t_normalData), 10)
# top genes
top_genes = results %>% arrange(`PValue`) %>% head(10) %$% Gene
# colors
my_colors = brewer.pal(n = 11, name = "RdBu")
pheatmap(normal_log2[top_genes, ], scale = "row", color = my_colors)
pheatmap(tumor_log2[top_genes, random_patients], scale = "row", color = my_colors)
pheatmap(normal_log2[top_genes, ],
scale = "row",
color = my_colors,
main = "Heatmap of Normal Data",
xlabel = "Random Samples",
ylabel = "Genes")
pheatmap(tumor_log2[top_genes, random_patients],
scale = "row",
color = my_colors,
main = "Heatmap of Tumor Data",
xlabel = "Random Samples",
ylabel = "Genes")
pheatmap(tumor_log2[top_genes, random_patients],
scale = "row",
color = my_colors,
main = "Heatmap of Tumor Data",
xlabel = "Random Samples",
ylabel = "Genes",
annotation_col = NULL)
pheatmap(tumor_log2[top_genes, random_patients],
scale = "row",
color = my_colors,
main = "Heatmap of Tumor Data",
xlabel = "Random Samples",
ylabel = "Genes",
annotation_col = rep("", length(random_patients)))
View(df)
data <- read.csv("Data2/LUSC_test.csv", sep = "|")
genes <- read.table("Data/frequently-mutated-genes.2024-03-18.tsv", header = TRUE, sep = "\t", fill = TRUE, quote = "")
# Remove duplicate rows
data <- data[!duplicated(data[, 1]), ]
#data <- data[1:6000, ]
# Transpose data
df <- t(data)
# Convert to data frame
df <- as.data.frame(df)
# Set column names
colnames(df) <- as.character(unlist(df[1, ]))
df <- df[-1, ]
# Drop ID Column
rownames(df) <- NULL
# convert to numeric
df[, -1] <- lapply(df[, -1], as.numeric)
# Impute NA with 0 since there are very few
df[is.na(df)] <- 0
# convert diagnosis to numeric
df$Diagnosis <- ifelse(df$Diagnosis == "normal", 0, 1)
# Calculate the sum of each column
column_sums <- colSums(df)
# Identify columns with sum not equal to zero
nonzero_columns <- which(column_sums != 0)
# Subset the dataframe to include only columns with sum not equal to zero
df <- df[, nonzero_columns, drop = FALSE]
# Convert diagnosis to a factor for easier subsetting
df$Diagnosis <- factor(df$Diagnosis)
# Split data into two groups based on Diagnosis
normalData <- subset(df, Diagnosis == 0)[,-1]
tumorData <- subset(df, Diagnosis == 1)[,-1]
# get genes of interest
genes_interest <- genes$symbol
# Initialize vectors to store results
log2FC <- numeric(ncol(df) - 1)  # Subtract 1 to exclude the Diagnosis column
pValues <- numeric(ncol(df) - 1)
for (i in 1:(ncol(df) - 1)) {
geneExpressionNormal <- normalData[,i]
geneExpressionTumor <- tumorData[,i]
# Calculate log2 Fold Change (tumor vs normal)
log2FC[i] <- log2(mean(geneExpressionTumor) / mean(geneExpressionNormal))
# Calculate p-value using Welch's t-test
pValues[i] <- t.test(geneExpressionTumor, geneExpressionNormal)$p.value
}
# Create a data frame to store results
results <- data.frame(
Gene = colnames(df)[-1],  # Exclude the Diagnosis column
Log2FoldChange = log2FC,
PValue = pValues
)
library(ggplot2)
# Convert p-values to -log10(p-value) for plotting
results$NegLogPValue <- -log10(results$PValue)
# Define up-regulated and down regulated genes
results$ChangeCategory <- with(results,
ifelse(PValue < 0.05 & Log2FoldChange > 1.5, "Upregulated",
ifelse(PValue < 0.05 & Log2FoldChange < -1.5, "Downregulated", "Nonsignificant")))
# Define genes of interest
results$IsInterest <- ifelse(results$Gene %in% genes_interest, "Yes", "No")
# Create the volcano plot
volcanoPlot <- ggplot(results, aes(x=Log2FoldChange, y=NegLogPValue, color=ChangeCategory)) +
geom_point(alpha=0.5) +
scale_color_manual(values=c("Upregulated"="royalblue4", "Downregulated"="red4", "Nonsignificant"="grey")) +
labs(x="Log2 Fold Change", y="-Log10 P-value", title="Volcano Plot of Gene Expression") +
theme_minimal() +
geom_hline(yintercept=-log10(0.05), linetype="dashed", color = "black") +  # Significance threshold line
theme(legend.title=element_blank(), legend.position="right")  # Customize legend
volcanoPlot <- volcanoPlot +
geom_vline(xintercept = -1.5, linetype = "dashed", color = "black") +
geom_vline(xintercept = 1.5, linetype = "dashed", color = "black")
# Add labels to genes of interest
volcanoPlot <- volcanoPlot + geom_text(data=subset(results, IsInterest == "Yes"), aes(label=Gene), vjust=-0.5, hjust=0.5, check_overlap = TRUE, size=3, color="black")
# Print the plot
print(volcanoPlot)
# filter for significant genes. p-value <0.05 and absolute value of fold change >1.5
result_mask <- subset(results, PValue < 0.05 & abs(Log2FoldChange) > 1.5)
# filter data
filtered <- df[, c("Diagnosis", intersect(colnames(df), result_mask$Gene))]
filtered <- as.data.frame(lapply(filtered, as.numeric))
filtered$Diagnosis <- ifelse(filtered$Diagnosis == 1, 0, ifelse(filtered$Diagnosis == 2, 1, filtered$Diagnosis))
# remove outliers from filtered data
filtered <- filtered[-97, , drop = FALSE] # 97
filtered <- filtered[-129, , drop = FALSE] # 128
filtered <- filtered[-121, , drop = FALSE] # 123
filtered <- filtered[-426, , drop = FALSE] # 429
filtered <- filtered[-476, , drop = FALSE] # 480
# filter normal
filteredNormal <- filtered[filtered$Diagnosis == 0, ]
filteredNormal <- filteredNormal[, -1]
filteredNormal <- as.data.frame(lapply(filteredNormal, as.numeric))
# filter tumor
filteredTumor <- filtered[filtered$Diagnosis == 1, ]
filteredTumor <- filteredTumor[,-1]
filteredTumor <- as.data.frame(lapply(filteredTumor, as.numeric))
# Scale data
scaled <- scale(filtered[, -1])
scaledNormal <- scale(filteredNormal)
scaledNormal <- replace(scaledNormal, is.na(scaledNormal), 0)
scaledTumor <- scale(filteredTumor)
# Function to add labels to genes with highest expression
add_labels_highest_expression <- function(data, num_labels) {
highest_genes <- colnames(data)[order(apply(data, 2, max), decreasing = TRUE)[1:num_labels]]
for (gene in highest_genes) {
expression_value <- max(data[, gene])
text(which(colnames(data) == gene), expression_value, gene, pos = 1, col = "red4", cex = 1)
}
}
# Plot boxplot for normalData expression
#boxplot(scaledNormal, outline = TRUE, main = "Normal Gene Expression")
#add_labels_highest_expression(scaledNormal, 3)
# Plot boxplot for tumorData expression
#boxplot(scaledTumor, outline = TRUE, main = "Tumor Gene Expression")
#add_labels_highest_expression(scaledTumor, 3)
library(tidyverse)
library(magrittr)
library(pheatmap)
library(RColorBrewer)
library(rio)
library(dplyr)
# transpose
t_normalData <- as.data.frame(t(normalData))
t_tumorData <- as.data.frame(t(tumorData))
# scale data
normal_log2 = log2(t_normalData + 1)
tumor_log2 = log2(t_tumorData + 1)
# Check for rows with constant values and exclude constant rows
remove_constant_rows <- function(data) {
constant_rows <- apply(data, 1, function(x) all(x == x[1]))
filtered_data <- data[!constant_rows, ]
return(filtered_data)
}
normal_log2 <- remove_constant_rows(normal_log2)
tumor_log2 <- remove_constant_rows(tumor_log2)
# Set seed for reproducibility
set.seed(123)
# random patients
random_patients = sample(colnames(t_tumorData), 50)
# random genes
random_genes = sample(rownames(t_normalData), 10)
# top genes
top_genes = results %>% arrange(`PValue`) %>% head(10) %$% Gene
# colors
my_colors = brewer.pal(n = 11, name = "RdBu")
# normal heat map
pheatmap(normal_log2[top_genes, ],
scale = "row",
color = my_colors,
main = "Heatmap of Normal Data",
xlabel = "Random Samples",
ylabel = "Genes")
# tumor heat map
pheatmap(tumor_log2[top_genes, random_patients],
scale = "row",
color = my_colors,
main = "Heatmap of Tumor Data",
xlabel = "Random Samples",
ylabel = "Genes")
library(factoextra)
# create filtered pca dataframe
pca_df <- data.frame(scaled)
pca_groups <- data.frame(Diagnosis = filtered$Diagnosis)
# perform pca
pca_result <- prcomp(pca_df, scale. = FALSE)
# Examine the summary of PCA result to decide on the number of components
#summary(pca_result)
# Select the Number of Principal Components
cumulative_var <- cumsum(pca_result$sdev^2) / sum(pca_result$sdev^2)
# Select components explaining at least 90% variance
#num_components <- which.max(cumulative_var >= 0.8)
#print(num_components)
# Extract a number of principal components, for example, the first two
num_components <- 2  # Adjust based on your analysis
pc_scores <- data.frame(pca_result$x[, 1:num_components])
# Add the Diagnosis back to the principal components dataframe and convert to factor
pc_scores <- cbind(pca_groups, pc_scores)
pc_scores$Diagnosis <- as.factor(pc_scores$Diagnosis)
pc_scores <- as.data.frame(pc_scores)
# Plot variance explained by each principal component to aid decision
#plot(pca_result, type = "l")
library("GGally")
# Extract the first 4 principal components
pca_subset <- pca_result$x[, 1:4]
# Assuming pca_subset is a matrix
pca_subset <- as.data.frame(pca_subset)
# Add diagnosis column to pca_subset
pca_subset$Diagnosis <- factor(pca_groups$Diagnosis, levels = c(0, 1), labels = c("normal", "tumor"))
# Visualize pair plot with hue as diagnosis using ggpairs function
ggpairs(pca_subset, aes(color = Diagnosis)) +
scale_color_manual(values = c("coral2", "cyan3"))
# PCA1 vs PCA2
fviz_pca_ind(pca_result,
geom.ind = "point",            # Show points only
col.ind = factor(pca_subset$Diagnosis, levels = unique(pca_subset$Diagnosis)),  # Color by groups
palette = c("coral2", "cyan3"),
addEllipses = TRUE,           # Concentration ellipses
legend.title = "Groups",
title = "PC1 vs PC2",
col.lab = c("normal" = "coral2", "tumor" = "cyan3"))
# Perform logistic regression using the principal components
lg_model <- glm(Diagnosis ~ ., data = pc_scores, family = "binomial")
lg_reduced <- glm(Diagnosis ~ PC1, data = pc_scores, family = "binomial")
# compare reduced with full model
anova(lg_reduced, lg_model, test = "LRT")
# the p-value is < 0.05.
# Therefore, we can reject the null hypothesis, suggesting that adding using 2 PCA components over 1 significantly improves the fit.
# Check the summary of the model
summary(lg_model)
# OR for PC1
#exp(coef(lg_model)["PC1"])
# The p-value is <0.05 so we conclude that PC1 gene expression is significantly associated with the presence of tumor.
# the odds of developing a tumor from PC1 gene expression is 4.45 times that of non-expression
# probability of developing tumor is (4.45-1) x 100 = 345% higher for PC1 gene expression
plot(lg_model)
